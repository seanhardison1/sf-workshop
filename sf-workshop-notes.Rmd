---
title: "spatial-intro"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, include = T, warning = F)

#A function to install and load missing packages

packages <- c("tidyverse", "sf", "stars", "raster", "here","rgdal", "lwgeom", "gstat")

installLoadPackages <- function(pkg){
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new.pkg)) 
        install.packages(new.pkg, dependencies = TRUE,repos='http://cran.us.r-project.org')
    sapply(pkg, require, character.only = TRUE)
}
installLoadPackages(packages)

#You'll also need the patchwork package from github!!

devtools::install_github("thomasp85/patchwork")
devtools::install_github("michaeldorman/nngeo")
library(nngeo)
library(patchwork)

#Set relative path to data directories here !!
epu.dir <- here::here("data","EPU_shapefile")
data.dir <- here::here("data")

```

## Data structures

### Check out the structure of an `sf` object. 
```{r view_structure}
nc <- st_read(system.file("shape/nc.shp", package="sf"), quiet = T)

head(nc)

# Note that nc is a collection of simple features, each of which is described by a row

```

### Now see what it looks like
```{r plot_nc}
plot(nc)
```

### Create the simplest simple feature geometry: a `POINT`
```{r make_points}

point_in_space <- c(1,2) #in XY space

point_geometry <- st_point(point_in_space)


point_geometry
plot(point_geometry)
```

### Combine multiple points into a `MULTIPOINT` geometry

```{r make_multipoints}
points_in_space <- rbind(c(3.2,4), c(3,4.6))

multipoint_geometry <- st_multipoint(points_in_space)


polygon_points <- list(rbind(c(1,0), c(0,5), c(0,5)))

plot(st_polygon(polygon_points))

multipoint_geometry
plot(multipoint_geometry)
```

### Create a `LINESTRING` using the same points

```{r make_linestring}
linestring_geometry <- st_linestring(points_in_space)

linestring_geometry
plot(linestring_geometry)
```

1. Create and plot a `POLYGON` geometry type using the function `st_polygon`

```{r build-polygon}

```


2. Create and plot a `GEOMETRYCOLLECTION` geometry type combining some of the above examples into one.

```{r build-geocol}

```

## Working with `sf`

### Getting `tidy` with it

1. Use your `dplyr` skills to determine the average `AREA` and `PERIMETER` of all North Carolina counties.

```{r getting-tidy}


```

2. Plot the top 10 largest counties in terms of `AREA` in North Carolina.

```{r plot-largest}


```

### `ggplot2` ft. `sf`

1. Using `ggplot2`, visualize the number of infant births by county between 1974-78 (`BIR74`). How would you visualize the change in birth rates between 1974-78 and 1979-84 (`BIR79`)?

```{r ggplot-sf}

```


### Reading spatial data

```{r epu_shapes}

#Read in shapefile using sf
sf_shape <- 
  st_read(file.path(epu.dir,"EPU_NOESTUARIES.shp"),quiet = T)

#Read in shapefile using rgdal
rgdal_shape <-
  readOGR(file.path(epu.dir,"EPU_NOESTUARIES.shp"),verbose = F)

epu <- sf_shape %>% dplyr::select(EPU)
plot(epu)
  
```

### Converting between `sf` and `sp` classes

* Check out the class of the shapefile loaded with `rgdal`
```{r sp_to_sf}
#Read in shapefile using rgdal
class(rgdal_shape)
```

* Convert to `sf` using `methods::as()`
```{r sp_to_sf2}

sf_shape <- as(rgdal_shape, "sf")

# Or the same thing in tidy style

sf_shape <- rgdal_shape %>% 
  as("sf")

class(sf_shape)
```


### Identify existing Coordinate Reference System
```{r st-crs, echo = TRUE}
st_crs(epu)
```


### Change the Coordinate Reference System
```{r st-transform}

#Pass a proj4string
p4s <- "+proj=longlat +datum=NAD27 +no_defs"
st_transform(epu, p4s)

#Pass an EPSG code
epsg <- 4627
st_transform(epu, epsg)
```

### Cropping sf objects: With a bounding box
```{r otis_topo, eval=T, echo = T}

load(file.path(data.dir, "topo_4ft.Rdata"))

#Define a bounding box
ymax <-  41.6525; xmin <- -70.5975
ymin <-  41.6425; xmax <- -70.59

bbox <- st_bbox(c(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), 
                crs = st_crs(topography))

#Turn it into an sf object for plotting only
grid_box <- st_make_grid(bbox) %>% st_cast("POLYGON")

ggplot() +
  geom_sf(data = topography, aes(color = ELEVATION)) +
  geom_sf(data = grid_box, alpha = 0, color = "red") +
  ggtitle("Topography of Francis-Crane Wildlife Area")

cropped_topo <- topography %>% st_crop(bbox)

ggplot() +
  geom_sf(data = cropped_topo, aes(color = ELEVATION)) +
  geom_sf(data = grid_box, alpha = 0, color = "red") +
  ggtitle("Topography of Francis-Crane Wildlife Area")

```


### Cropping sf object: With an arbitary polygon

```{r ind_diff, eval = T}
custom_polygon <- sf::st_read(file.path(data.dir, "Polygon_shapefile", "polygon_for_crop.shp"), 
                              quiet = T) %>% st_transform(st_crs(topography))

#Intersection
topo_intersection <- topography %>% st_intersection(custom_polygon)

#Difference
topo_difference <- topography %>% st_difference(custom_polygon)

#Plotting
int <- ggplot() +
  geom_sf(data = topo_intersection, aes(color = ELEVATION)) +
  guides(color = F) + ggtitle("Intersection")

difff <- ggplot() +
  geom_sf(data = topo_difference, aes(color = ELEVATION)) +
  guides(color = F) + ggtitle("Difference")

int + difff + plot_layout(ncol = 2)
```

### Spatial Joins

```{r join_epu, eval=T, echo = T}
sf_shape <- st_read(file.path(epu.dir,"EPU_NOESTUARIES.shp"),quiet = T) 

#Get the union of all EPUs
all_joined <- st_union(sf_shape)

#Create a grouping column to union New England EPU polygons
some_joined <- sf_shape %>% mutate(Region = ifelse(EPU %in% c("GOM","GB","SS"),
                                "New England",
                                "Mid-Atlantic")) %>% 
  group_by(Region) %>% 
  summarise()

all_joined <- ggplot() + geom_sf(data = all_joined, color = "blue") +
  guides(color = F) 

some_joined <- ggplot() + geom_sf(data = some_joined, aes(color = Region)) +
  guides(color = F)

all_joined + some_joined + plot_layout(ncol = 2)
```

### Putting it all together: An example with fake fish data

```{r fake_fishies}
load(file = file.path(data.dir, "catch_data.rdata"))

#Turn a data.frame into an sf object
catch_sf <- st_as_sf(catch, coords = c("X","Y"), crs = st_crs(sf_shape)) 

#Get length quantiles for our catch data
quantiles <- quantile(catch_sf$length, probs = seq(0,1,0.2))

#Join points into shapefile based on where they fall in the polygon
catch_sf <- st_join(catch_sf, sf_shape) %>% 
  mutate(quantiles = dplyr::case_when(length <= quantiles[2] ~ "first",
                                     length > quantiles[2] & length <= quantiles[3] ~ "second",
                                     length > quantiles[3] & length <= quantiles[4] ~ "third",
                                     length > quantiles[4] & length <= quantiles[5] ~ "fourth",
                                     length > quantiles[5] ~ "fifth"))

catch_sf$quantiles <- factor(catch_sf$quantiles,
                             levels = c("first","second","third","fourth","fifth"))

#Calculate quantiles for length data
ggplot() + 
  geom_sf(data = sf_shape) +
  geom_sf(data = catch_sf, aes(color = quantiles), show.legend = "point") +
  guides(color = guide_legend(title = "Length Quantiles")) +
  theme(legend.position='bottom')
```

### Nearest neighbor interpolation

```{r NNI_p1}

# Create a raster grid to interpolate over
r1 <- raster::raster()
e <- raster::extent(-76.83333, -65.66667, 34, 44.5)
raster::extent(r1) <- e
r1[] <- 1
crs(r1) <- crs(catch_sf)
 
#Convert our object to a SpatialPolygon and then into a raster. 
spdf <- sf_shape %>%
  st_union() %>% #Union all polygons
  st_transform(st_crs(catch_sf)) %>% #Make sure it has the same CRS as the fake fish data.
  as_Spatial()

polygon_rast <- raster::rasterize(spdf, r1) #Rasterize

#Convert our fake lengths sf object to SpatialPointsDataFrame for model input
catch_spatial_points <-
  catch_sf %>% 
  as_Spatial()

spatial_mod <- gstat::gstat(formula = length~1,
                            locations = catch_spatial_points, nmax = 5, set = list(idp = 0))

#idp: inverse distance power; when 0, all neighbors weighted equally
#nmax: n

plot(variogram(spatial_mod))


#Predict over the raster space
nn <- raster::interpolate(r1, spatial_mod)

#Check out the model output
plot(nn)
```


```{r NNI_p2}
#Mask the raster according to the original polygon extents
masked_model_output <- mask(nn, polygon_rast)

stars_output <- stars::st_as_stars(masked_model_output)


ggplot() +
  geom_stars(data = stars_output) +
  geom_sf(data = sf_shape, aes(color = EPU), fill = "transparent") 

```

## Simple Features (sf)

https://r-spatial.github.io/sf/articles/sf1.html

* What are `simple features`?

  * A formally recognized standard for encoding spatial information 
  * Implemented widely in spatial databases and commercial GIS outside of R (e.g. PostGIS, ArcGIS)
  * A data structure with both spatial and non-spatial attributes
  
* Why `sf`?
  * Methods for interfacing with spatial data have existed for a long time in R, but using them is a pain.
  * `sf` is built to be the successor to these sometimes painful libraries, such as `sp`
  
* What is a feature?
  * A feature is a real-world object (forests are features, but so are trees in the forests.)

* What's in a feature?
  * Geometry - A descriptor of location.
  * Attributes - Descriptors of feature properties (e.g. temperature)
  * Show diagram
  
* Interacting with simple features in R
  * All functions and methods in `sf` begin with `st_`
  * Attributes and geometries are stored as `data.frame` columns
  
* What's the difference between a GEOMETRY and GEOMETRYCOLLECTION?
  * If a single sf contains more than one *type* of GEOMETRY, it is a GEOMETRYCOLLECTION
  * For example, a single simple feature with both points and lines would be of type GEOMETRYCOLLECTION

* What's the difference between a POLYGON and a MULTIPOLYGON geometry type?
  * POLYGONs are allowed to have an exterior ring and zero or more interior rings
  * MULTIPOLYGONS are composed of multiple POLYGONS
  * This means that MULTIPOLYGONs are lists of lists of matrices
  
* How are data represented in different geometries?
  * All geometries are represented as lists of matrices (code example)
  
* What is a `proj4string` and how is it used?
  * All geometries in an `sf` object must have the same coordinate reference system (CRS)
  * A generic, string-based description of a coordinate reference system. 
  * The `proj4string` conveys information about a given coordinate transformation, that is, how geospatial information should be represented on a piece of paper. Included within the `proj4string` is a projection argument. This describes a mathematical transformation of a section of a spheroid onto a 2D surface. 
    * A datum. The datum defines the size, orientation, and position of an ellipsoid that approximates the shape of the earth. It forms a reference point for coordinate pairs.
  * `epsg`: An integer code for a specific coordinate reference system that can be resolved into a `proj4string`

* Transforming CRSs:
  * CRS transformations are performed using `st_transform()` in `sf`.
  * This method allows for use to convert between datum types. For example, between lat/lon in NAD27 datum to web mercator (used by web maps like Google Maps). Web mercator 
https://gis.stackexchange.com/questions/664/difference-between-projection-and-datum


```{r}
library(sf)

nc <- st_read(system.file("shape/nc.shp", package="sf"))

```

